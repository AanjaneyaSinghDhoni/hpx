[/==============================================================================
    Copyright (C)      2017 Adrian Serio

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section:utilities Utilities in __hpx__]

In order to ease the burden of programming in __hpx__ we have provided 
several utilities to users. The following section documents those
facilies.

[section:checkpoint Checkpoint]

A common need of users is to periodically backup an application.
This practice provides resiliency and potential restart points in code.
We have developed the concept of a [^checkpoint] to support this 
usecase.

Found in [^hpx/util/checkpoint.hpp] [^checkpoint]s are defined as 
objects which hold a serialized version of an object or set of objects
at a particular moment in time.
This representation can be stored in memory for later use or it can 
be written to disk for storage and/or recovery at a later point.
In order to create and fill this object with its data we use a 
function called [^save_checkpoint]. In code the function looks
like this:

```
hpx::future<hpx::util::checkpoint> hpx::util::save_checkpoint(a, b, c, ...);
```

[^save_checkpoint] takes arbitrary data containters such as int, 
double, float, vector, and future and serializes them into a newly
created [^checkpoint] object. This function returns a [^future] to a 
[^checkpoint] containing the data. Let us look a simple usecase 
below:

```
using hpx::util::checkpoint;
using hpx::util::save_checkpoint;

std::vector<int> vec{1,2,3,4,5};
hpx::future<checkpoint> save_checkpoint(vec);
```

Once the future is ready the checkpoint object will contain
the [^vector] vec and its five elements.

It is also possible to modify the launch policy used by 
[^save_checkpoint]. This is accomplished by passing a launch policy as
the first argument. It is important
to note that passing hpx::launch::sync will cause [^save_checkpoint] to 
return a [^checkpoint] instead of a [^future] to a [^checkpoint]. All other 
policies passed to [^save_checkpoint] will return a [^future] to a [^checkpoint].

Sometimes [^checkpoint]s must be declared before they are used.
[^save_checkpoint] allows users to move pre-created [^checkpoint]s into
the function as long as they are the first container passing into the 
function (In the case where a launch policy is used the [^checkpoint]
will immediatly follow the launch policy). An example of these features
can be found below:

[import ../../tests/unit/util/checkpoint.cpp]
[check_test_1]

Now that we can create [^checkpoint]s we now must be able to restore 
the objects they contain in memory. This is accomplished by the 
function [^restore_checkpoint]. This function takes a [^checkpoint]
and fills its data into the containers it is provided. It is important
to remember that the containers must be ordered in the same way 
they were placed into the [^checkpoint]. For clarity see the example 
below:

[check_test_2] 

[endsect]

[endsect]
